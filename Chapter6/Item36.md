# 항목 36. 상속받은 비가상 함수를 파생 클래스에서 재정의하는 것은 절대 금물!
### 비가상 함수의 상속과 재구현
```cpp
class B{
public:
    void f(); // 비가상 함수
};

class D : public B{
public:
    void f(); // B::mf를 가린다
}

D x;
B * pb = &x;
D * pd = &x;

pb->f(); // B::f()를 호출한다.
pd->f(); // D::f()를 호출한다.
```
- 비가상 함수 `f`를 파생 클래스에서 재정의 한다면 함수도 똑같고 객체도 똑같으나 **실제로 호출이 다른 문제**가 발생한다.
- `public` 상속에서 `is-a` 관계에 모순이 발생한다.
- `D`가 `B`의 일종이고 `f`가 클래스 상속과는 상관없는 `B`의 불변동작에 해당한다면 `D`에서는 `f`를 재정의할 생각을 하면 안된다.

### 다른 호출이 발생하는 이유
- 비가상 함수는 [정적 바인딩](/Chapter6/Item37.md)으로 묶인다.
    - `pb`는 **B에 대한 포인터**타입으로 선언되었기 때문에, `pb`를 통해 호출되는 비가상 함수는 항상 `B 클래스`에 정의되어 있을 것이라고 결정해 버린다.
    - `B`, `D`를 좌우하는 요인이 객체 자신이 아니라 **객체를 가리키는 포인터**의 타입이 된다.
- 가상 함수는 [동적 바인딩](/Chapter6/Item37.md)으로 묶인다.
    - `f` 함수가 가상 함수였다면 `f`가 `pb`에서 호출되든 `pd`에서 호출되든 `D::mf`가 호출된다.
    - `pb`, `pd`가 실제로 가리키는 대상은 **D 타입**의 객체이기 때문이다.