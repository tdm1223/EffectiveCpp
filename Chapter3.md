# 자원관리
- 자원 : 사용을 마치고 난 후에 시스템에 돌려주어야 하는 모든 것
- 파일 디스크립터, 뮤텍스 락, GUI에서 쓰이는 폰트와 브러시, DB 연결, 네트워크 소켓 모두 자원이다.

## 항목 13. 자원관리에는 객체가 그만
### 누수가 일어날 수 있는 코드
```cpp
void f
{
    Investment *pInv = createInvestment(); // 파생된 클래스의 객체를 얻어내는 팩토리 함수
    // return? goto? continue? exception?
    delete pInv;
}
```
- `createInvestment()` 함수로 부터 얻은 **객체의 삭제를 실패**할 수 있는 경우가 존재한다.
- `return`, `goto`, `continue`, 예외발생등의 경우를 통해 삭제가 이루어지지않고 함수를 빠져나올수가 있다.
- 제대로 종료되지 않는다면 메모리가 누출되고, 그 객체가 갖고 있던 자원까지 모두 샌다.
- 얻어낸 자원이 항상 해제되도록 하려면, 자원을 객체에 넣고 그 자원 해제를 소멸자가 맡도록 하며, 소멸자는 실행제어가 `f`를 떠날 때 호출되도록 만드는 것이다.
- 표준 라이브러리에 해당 용도에 쓰라고 만든 클래스인 `auto_ptr`이 존재한다.

### auto ptr을 사용하여 코드 수정
```cpp
void f()
{
    std::auto_ptr<Investment> pInv(createInvestment()); // 팩토리 함수 호출
}

```

### 위 코드의 특징
1. 자원을 획득한 후에 자원 관리 객체에게 넘긴다.
2. 자원 관리 객체는 자신의 소멸자를 사용해서 자원이 확실히 해제되도록 한다.

- `auto_ptr`은 자신이 소멸될 때 가리키고 있는 대상에 대해 자동으로 delete를 먹이기 때문에, 어떤 객체를 가리키는 auto_ptr의 개수가 둘 이상이면 절대로 안된다. (두번 삭제가 발생)
- `auto_ptr`로 객체를 복사하면 원본 객체를 `null`로 만든다.
- STL 컨테이너의 경우엔 원소들이 정상적인 복사 동작을 가져야 하기 떄문에, `auto_ptr`은 이들의 원소로 허용되지 않는다.

### 참조 카운팅 방식 스마트 포인터(RCSP)
- `auto_ptr`을 사용할 수 없는 상황일때 사용하기 좋은 스마트 포인터이다.
- `RCSP`는 자원을 가리키는 외부 객체의 개수를 유지하고 있다가 개수가 0이 되면 해당 자원을 자동으로 삭제한다.
- 동작이 가비지 컬렉션과 유사하다.
- 참조 상태가 고리를 이루는 경우는 없앨 수 없다.(가비지 컬렉션과 다른점)
- `shared_ptr`이 대표적인 `RCSP`이다.

### 스마트포인터 주의사항
- `delete[]` 연산자가 아닌 `delete`연산자를 사용하기 때문에 동적으로 할당한 배열에 대해 `auto_ptr`이나 `shared_ptr`을 사용하면 안된다.
- 동적 배열을 썼을 때 컴파일 에러가 나지 않기 때문에 더 주의해야 한다.

## 항목 14. 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하기
- RAII(Resource Acquisition Is Initialization) : 자원 획득 및 초기화

### RAII 객체가 복사될 때 어떤 동작이 이루어져야 할까
1. **복사를 금지**한다.
    - RAII 객체가 복사되도록 놔두는 것 자체가 말이 안되는 경우가 많다.
    - 복사를 막는것은 이전에 학습한 복사 연산을 `private` 멤버로 만드는 방법을 사용하면 된다.
2. 관리하고 있는 자원에 대해 **참조 카운팅**을 수행한다.
    - 자원을 참조하는 객체의 개수에 대한 카운트를 증가시키는 식으로 RAII 객체의 복사 동작을 만든다.
    - `shared_ptr`에서 삭제자를 지정한다.
    ```cpp
    class Lock
    {
    public:
        explicit Lock(Mutex *pm) : mutexPtr(pm, unlock) // 삭제자로 unlock 함수 사용
        {
            lock(mutexPtr.get());
        }
    private:
        std::shared_ptr<Mutex> mutexPtr; // 원시 포인터 대신 shared_ptr을 사용
    }
    ```
    - Lock 클래스가 이제는 소멸자를 선언하지 않는다.(필요없기 때문)
    - `mutexPtr`의 소멸자는 뮤텍스의 참조 카운트가 0이 될 때 `shared_ptr`의 삭제자를 자동으로 호출한다.
3. 관리하고 있는 자원을 **진짜로 복사**한다.
    - 자원 관리 객체를 복사하면 객체가 둘러싸고 있는 자원까지 복사되어야 한다.(깊은 복사)
4. 관리하고 있는 자원의 **소유권**을 옮긴다.
    - `auto_ptr`의 복사 동작처럼 소유권을 사본으로 옮긴다.

## 항목 15. 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하기
- RAII 클래스의 객체를 객체가 감싸고 있는 실제 자원으로 변환할 방법이 필요할때가 있다.
- 일반적인 방법으로는 아래 두가지 방법이 있다.
    1. 명시적 변환 : 안정성
    2. 암시적 변환 : 고객 편의성
- `shared_ptr` 및 `auto_ptr`은 **명시적 변환**을 수행하는 `get`이라는 멤버 함수를 제공한다.
- `get`함수를 통해 스마트 포인터 객체에 들어있는 실제 포인터를 얻어낼 수 있다.
- `RAII` 클래스는 애초부터 데이터 은닉이 목적이 아니다.
- 원하는동작이 실수 없이 이루어지도록 하면 된다.

## 항목 16. new 및 delete를 사용할 때는 형태를 반드시 맞추기
```cpp
std::string * stringArr = new std::string[100];

delete stringArr;
```
- 100개의 `string` 객체들 가운데 99개는 정상적인 소멸 과정을 거치지 못할 가능성이 크다.
- `new` 연산자를 사용해서 표현식을 쓸 경우
    1. 메모리 할당
    2. 할당된 메모리에 대해 한 개 이상의 생성자가 호출
- `delete` 연산자를 사용해서 표현식을 쓸 경우
    1. 기존에 할당된 메모리에 대해 한 개 이상의 소멸자 호출
    2. 메모리 해제
- `new` 표현식에 `[]`를 썼으면, 대응되는 `delete` 표현식에도 `[]`를 써야 한다.
- std에는 `string`, `vector`같은 클래스 템플릿이 있어서 잘 활용하면 동적 할당 배열이 필요해질 경우가 거의없다. (`vector<string>`사용)

## 항목 17. new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들기
```cpp
processWidget(std::shared_ptr<Widget>(new Widget), priority());
```

### 위 코드의 문제 가능성
- `processWidget` 호출 코드를 만들기 전에 컴파일러는 아래 세가지 연산을 위한 코드를 만들어야 한다.
    1. `new Widget` 표현식을 실행하는 부분
    2. `shared_ptr` 생성자를 호출하는 부분
    3. `priority()`를 호출하는 부분
- 자원 관리 객체를 쓰고 있지만 자원을 흘릴 가능성이 있다.

### 원인
- 연산의 실행 순서가 컴파일러 제작사마다 다르다.
- `new Widget` -> `priority()` -> `shared_ptr`순으로 호출이 되고 `priority()`에서 예외가 발생한다면 `new widget`으로 만들어졌던 **포인터가 유실**될 수 있다.
- 즉, **자원이 생성되는 시점**과 **자원이 자원 관리 객체로 넘어가는 시점** 사이에 예외가 끼어들 수 있다.

### 해결 방법
- 스마트 포인터에 저장하는 코드를 별도의 문장 하나로 만들고, 스마트 포인터를 `processWidget`에 넘기면 된다.
