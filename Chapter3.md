# 자원관리
- 자원 : 사용을 마치고 난 후에 시스템에 돌려주어야 하는 모든 것
- 파일 디스크립터, 뮤텍스 락, GUI에서 쓰이는 폰트와 브러시, DB 연결, 네트워크 소켓 모두 자원이다.

## 자원관리에는 객체가 그만!
### 누수가 일어날 수 있는 코드
```cpp
void f
{
    Investment *pInv = createInvestment(); // 파생된 클래스의 객체를 얻어내는 팩토리 함수
    // return? goto? continue? exception?
    delete pInv;
}
```
- `createInvestment()` 함수로 부터 얻은 객체의 삭제에 실패할 수 있는 경우가 존재한다.
- `return`, `goto`, `continue`, 예외발생등의 경우를 통해 삭제가 이루어지지않고 함수를 빠져나올수가 있다.
- 제대로 종료되지 않는다면 메모리가 누출되고, 그 객체가 갖고 있던 자원까지 모두 샌다.
- 얻어낸 자원이 항상 해제되도록 하려면, 자원을 객체에 넣고 그 자원 해제를 소멸자가 맡도록 하며, 소멸자는 실행제어가 `f`를 떠날 때 호출되도록 만드는 것이다.
- 표준 라이브러리에 해당 용도에 쓰라고 만든 클래스인 `auto_ptr`이 존재한다.

### auto ptr을 사용하여 코드 수정
```cpp
void f()
{
    std::auto_ptr<Investment> pInv(createInvestment()); // 팩토리 함수 호출
}

```

### 위 코드의 특징
1. 자원을 획득한 후에 자원 관리 객체에게 넘긴다.
2. 자원 관리 객체는 자신의 소멸자를 사용해서 자원이 확실히 해제되도록 한다.

- `auto_ptr`은 자신이 소멸될 때 가리키고 있는 대상에 대해 자동으로 delete를 먹이기 때문에, 어떤 객체를 가리키는 auto_ptr의 개수가 둘 이상이면 절대로 안된다. (두번 삭제가 발생)
- `auto_ptr`로 객체를 복사하면 원본 객체를 `null`로 만든다.
- STL 컨테이너의 경우엔 원소들이 정상적인 복사 동작을 가져야 하기 떄문에, `auto_ptr`은 이들의 원소로 허용되지 않는다.

### 참조 카운팅 방식 스마트 포인터(RCSP)
- `auto_ptr`을 사용할 수 없는 상황일때 사용하기 좋은 스마트 포인터이다.
- `RCSP`는 자원을 가리키는 외부 객체의 개수를 유지하고 있다가 개수가 0이 되면 해당 자원을 자동으로 삭제한다.
- 동작이 가비지 컬렉션과 유사하다.
- 참조 상태가 고리를 이루는 경우는 없앨 수 없다.(가비지 컬렉션과 다른점)
- `shared_ptr`이 대표적인 `RCSP`이다.

### 스마트포인터 주의사항
- `delete[]` 연산자가 아닌 `delete`연산자를 사용하기 때문에 동적으로 할당한 배열에 대해 `auto_ptr`이나 `shared_ptr`을 사용하면 안된다.
- 동적 배열을 썼을 때 컴파일 에러가 나지 않기 때문에 더 주의해야 한다.

## 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하기
- RAII(Resource Acquisition Is Initialization) : 자원 획득 및 초기화

### RAII 객체가 복사될 때 어떤 동작이 이루어져야 할까
1. **복사를 금지**한다.
    - RAII 객체가 복사되도록 놔두는 것 자체가 말이 안되는 경우가 많다.
    - 복사를 막는것은 이전에 학습한 복사 연산을 `private` 멤버로 만드는 방법을 사용하면 된다.
2. 관리하고 있는 자원에 대해 **참조 카운팅**을 수행한다.
    - 자원을 참조하는 객체의 개수에 대한 카운트를 증가시키는 식으로 RAII 객체의 복사 동작을 만든다.
    - `shared_ptr`에서 삭제자를 지정한다.
    ```cpp
    class Lock
    {
    public:
        explicit Lock(Mutex *pm) : mutexPtr(pm, unlock) // 삭제자로 unlock 함수 사용
        {
            lock(mutexPtr.get());
        }
    private:
        std::shared_ptr<Mutex> mutexPtr; // 원시 포인터 대신 shared_ptr을 사용
    }
    ```
    - Lock 클래스가 이제는 소멸자를 선언하지 않는다.(필요없기 때문)
    - `mutexPtr`의 소멸자는 뮤텍스의 참조 카운트가 0이 될 때 `shared_ptr`의 삭제자를 자동으로 호출한다.
3. 관리하고 있는 자원을 **진짜로 복사**한다.
    - 자원 관리 객체를 복사하면 객체가 둘러싸고 있는 자원까지 복사되어야 한다.(깊은 복사)
4. 관리하고 있는 자원의 **소유권**을 옮긴다.
    - `auto_ptr`의 복사 동작처럼 소유권을 사본으로 옮긴다.
