# 항목 19. 클래스 설계는 타입 설계와 똑같이 취급하자
- `C++`에서 **새로운 클래스**를 정의하는 것은 **새로운 타입**을 하나 [정의](/Chapter0/Item0.md)하는것이다.
- 함수와 연산자 오버로드, 메모리 할당 및 해제 제어, 객체 초기화 및 종료처리 정의 모두 설계할 수 있다.
- 좋은 타입을 설계하는것은 까다롭다.

## 좋은 타입?
- 문법이 자연스럽다.
- 의미구조가 직관적이다.
- 효율적인 구현이 한 가지 이상 가능해야 한다.

## 클래스를 설계할때 고려해야할 질문들
### 1. 새로 정의한 타입의 객체 생성 및 소멸은 어떻게 이루어져야 하는가
- **생성자** 및 **소멸자**의 설계가 바뀐다.
- **메모리 할당 함수**를 직접 작성할 경우 위 함수의 설계에도 영향을 미친다.

### 2. 객체 초기화는 객체 대입과 어떻게 달라야 하는가
- 생성자와 대입 연산자의 동작과 차이점을 결정 짓는 요소이다.
- [초기화와 대입 각각에 해당되는 함수 호출이 다르기 때문에](/Chapter1/Item4.md) 헷갈리지 않아야 한다.

### 3. 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가
- **값에 의한 전달**을 구현하는 쪽은 **복사 생성자**이다.

### 4. 새로운 타입이 가질 수 있는 **값에 대한 제약**은 무엇으로 잡을 것인가
- 클래스 멤버의 몇 가지 조합 값은 반드시 유효해야 한다. (클래스의 불변속성)
- 특히 생성자, 대입 연산자, 쓰기 함수가 중요하다.

### 5. 기존의 클래스 상속 계통망에 맞출 것인가
- 이미 존재하는 클래스로부터 상속을 시킬때 멤버 함수가 [가상인가 비가상인가](/Chapter6/Item34.md)의 [여부가 상속에 중요](/Chapter6/Item36.md)하다.

### 6. 어떤 종류의 타입 변환을 허용할 것인가
- **암시적 변환**을 허용하고 싶다면?
    - 타입 변환 함수를 만든다.
    - 인자 한 개로 호출될 수 있는 비명시호출 생성자를 만든다.
- **명시적 변환**만 허용하고 싶다면?
    - 해당 변환을 맡는 별도 이름의 함수를 만들되 타입 변환 연산자 혹은 비명시호출 생성자는 만들지 말아야 한다.

### 7. 어떤 연산자와 함수를 두어야 의미가 있을까
- [클래스 안에](/Chapter4/Item23.md) [선언할 함수가](/Chapter4/Item24.md) [여기서 결정된다](/Chapter7/Item46.md).

### 8. 표준 함수들 중 어떤 것을 허용하지 말 것인가
- [private로 선언해야 하는 함수들](/Chapter2/Item6.md)이 해당된다.

### 9. 새로운 타입의 멤버에 대한 **접근권한**을 어느 쪽에 줄 것인가
- `public`, `protected`, `private` 중 어느것으로 선언할지 결정해야 한다.

### 10. 선언되지 않은 인터페이스로 무엇을 둘 것인가
- 만드는 타입의 [수행 성능, 예외 안전성](/Chapter5/Item29.md), 자원사용(잠금 및 동적메모리)이 보장되어야 한다.

### 11. 새로 만드는 타입이 얼마나 일반적인가
- 타입 하나를 정의하는 것이 아니고 동일 계열의 타입군 전체를 정의해야 할 수도 있다.
- 동일 계열의 타입군 **전체**라면 새로운 클래스가 아닌 **클래스 템플릿**을 정의해야 한다.

### 12. 정말로 필요한 타입인가
- 기존 클래스에 대해 기능 일부가 아쉬워서 파생 클래스를 새로 만들고 있다면?
    - **비멤버 함수**나 **템플릿**을 몇 개 더 정의하는 편이 낫다.