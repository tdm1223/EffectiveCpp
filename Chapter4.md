# 설계 및 선언

## 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게
### 문제를 야기할 수 있는 인터페이스
- 날짜를 나타내는 `Date` 클래스에 넣을 생성자를 설계해본다.
- 아래 `Date` 클래스는 두가지 문제를 야기할 수 있다.
```cpp
class Date{
public:
    Date(int month, int day, int year);
}
```
1. 매개변수의 전달 순서가 잘못될 여지가 있다. 
    - `month : 3, day : 30`을 `month : 30, day : 3`으로 입력할 가능성이 있다.
2. 월과 일에 해당하는 숫자가 어이없는 숫자일 수 있다.
    - `day : 30` 을 `day : 50`으로 입력할 가능성이 있다.

### 해결방법
1. 일, 월, 연을 구분하는 간단한 랩퍼 타입을 만들고 이 타입을 `Date` 생성자 안에 들 수 있다.
2. **타입에 제약을 부여**하여 타입을 통해 할 수 있는 일들을 묶는다.

### 제대로 쓰기에 괜찮은 인터페이스
- 일관성 있는 인터페이스를 제공하기 위해서는 기본 제공 타입과 쓸데없이 어긋나는 동작을 피해야 한다.
- 괜찮은 인터페이스를 만들어 주는 요인중 하나는 **일관성**이다.
    - 모든 STL 컨테이너는 크기를 반환하는 `size`란 멤버 함수를 통해 일관성을 제공한다.
- 사용자 쪽에서 뭔가를 외워야 제대로 쓸 수 있는 인터페이스는 잘못 쓰기 쉽다.
    - 언제라도 잊어버릴 수 있다.

### 교차 DLL문제
- 객체 생성 시에 어떤 동적 링크 라이브러리의 `new`를 썻는데 그 객체를 삭제할 떄는 **이전의 DLL과 다른 DLL**에 있는 `delete`를 썼을경우 발생한다.
- `new/delete`가 실행되는 DLL이 달라서 꼬이게 되면 런타임 에러가 발생한다.

### 해결방법
- `shared_ptr`을 사용하면 문제를 피할 수 있다.
    - 클래스의 기본 삭제자는 `shared_ptr`이 생성된 DLL과 동일한 DLL에서 delete를 사용하도록 만들어져 있기 때문이다.
- `shared_ptr`은 다른 DLL들 사이에 이리저리 넘겨지더라도 교차 DLL 문제를 걱정하지 않아도 된다.

## 클래스 설계는 타입 설계와 똑같이 취급하기
- C++에서 새로운 클래스를 정의하는 것은 새로운 타입을 하나 정의하는것이다.

### 클래스를 설계할때 고려해야할 질문들
1. 새로 정의한 타입의 객체 생성 및 소멸을 어떻게 이루어져야 하는가
    - 생성자 및 소멸자의 설계가 바뀐다.
    - 메모리 할당 함수를 직접 작성할 경우 위 함수의 설계에도 영향을 미친다.
2. 객체 초기화는 객체 대입과 어떻게 달라야 하는가
    - 초기화와 대입을 헷갈리지 않아야 한다.
3. 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가
    - 값에 의한 전달을 구현하는 쪽은 복사 생성자이다.
4. 새로운 타입이 가질 수 있는 적법한 값에 대한 제약은 무엇으로 잡을 것인가
    - 클래스 멤버의 몇 가지 조합 값은 반드시 유효해야 한다.
    - 생성자, 대입 연산자, 쓰기 함수는 특히 중요하다.
5. 기존의 클래스 상속 계통망에 맞출 것인가
    - 이미 갖고 있는 클래스로부터 상속을 시킬때 멤버 함수가 가상인가 비가상인가의 여부가 상속에 중요하다.
6. 어떤 종류의 타입 변환을 허용할 것인가
    - 암시적 변환을 허용할것이라면 타입 변환 함수를 추가한다.
    - 명시적 변환만 허용하고 싶다면?
7. 어떤 연산자와 함수를 두어야 의미가 있을까
    - 클래스 안에 선언할 함수가 여기서 결정된다.
8. 표준 함수들 중 어떤 것을 허용하지 말 것인가
    - private로 선언해야 하는 함수들
9. 새로운 타입의 멤버에 대한 접근권한을 어느 쪽에 줄 것인가
    - public, protected, private 영역 중 어디에 둘 것인가를 결정해야 한다.
10. 선언되지 않은 인터페이스로 무엇을 둘 것인가
11. 새로 만드는 타입이 얼마나 일반적인가
    - 타입 하나를 정의하는 것이 아닐지도 모른다.
    - 동일 계열의 타입군 전체라면 클래스 템플릿을 정의해야 한다.
12. 정말로 필요한 타입인가
    - 기존 클래스에 대해 기능 몇 개가 아쉬워서 파생 클래스를 새로 뽑고 있다면, 비멤버 함수나 템플릿을 몇 개 더 정의하는 편이 낫다.
