# 항목 29. 예외 안정성이 확보되는 그날 위해 싸우고 또 싸우자!
- 소프트웨어 시스템은 예외에 **안전**하거나, 예외에 **뚫려** 있거나 둘중 하나이다.
- 예외 안전성이 없는 함수가 한 개라도 쓰고 있으면, 그 시스템은 전부가 예외에 안전하지 않은 시스템이다.

### 예외 안전성을 가진 함수
- 예외 안전성을 가진 함수는 예외가 발생할 때 아래와 같이 동작한다.
1. **자원**이 새도록 만들지 않는다.
2. **자료구조**가 더럽혀지는 것을 허용하지 않는다.

### 예외 안전성을 갖춘 함수는 아래 보장(guarantee)중 하나를 제공한다.
- 아무 보장도 제공하지 않으면 예외에 안전한 함수가 아니다.
1. 기본적인 보장(basic guarantee)
    - 함수 동작 중에 예외가 발생하면, 실행 중인 프로그램에 관련된 모든 것들을 **유효한 상태로 유지**하겠다는 보장
    - 어떤 객체나 자료구조도 더럽혀지지 않으며, 모든 객체의 상태는 내부적으로 일관성을 유지하고 있다.
    - 프로그램 상태가 정확히 어떠한지 예측이 안 될 수도 있다.
2. 강력한 보장(basic guarantee)
    - 함수 동작 중에 예외가 발생하면, 프로그램의 상태를 **절대로 변경하지 않겠다**는 보장
    - 호출이 성공하면 마무리까지 완벽하게 성공하고, 호출이 실패하면 함수 호출이 없었던 것처럼 프로그램의 상태가 되돌아 간다.
3. 예외불가 보장(basic guarantee)
    - 예외를 **절대로 던지지 않겠다**는 보장
    - 약속한 동작은 언제나 끝까지 완수하는 함수
    - 기본 제공 타입(int, 포인터 등)에 대한 모든 연산은 예외를 던지지 않게 되어있다.

- 현실적으로 대부분의 함수에 있어서 **기본적인 보장**과 **강력한 보장** 중 하나를 고르게 된다.

### 복사 후 맞바꾸기 전략
- **강력한 예외 안전성 보장**을 제공하기 위한 설계 전략
    - 어떤 객체를 수정하고 싶으면 그 객체의 **사본**을 하나 만들어 놓고 그 **사본을 수정**하는 것
    - 수정 동작 중에 실행되는 연산에서 예외가 전져지더라도 원본 객체는 바뀌지 않는다.
    - 필요한 동작이 전부 성공적으로 완료되고 나면 수정된 객체를 원본 객체와 맞바꾼다.(예외를 전지지 않는 연산 내부에서 수행)
- 진짜 객체의 모든 데이터를 별도의 구현 객체에 넣어두고 구현 객체를 가리키는 포인터를 진짜 객체가 물고 있게 하는 식으로 구현한다.
    - pimpl 관용구라고도 한다.
- 수정하고 싶은 객체를 복사해 둘 공간과 복사에 걸리는 시간을 감수해야 한다.

### 함수의 부수효과(side effect)
- 자기 자신에 국한된 것들의 상태를 바꾸며 동작하는 함수의 경우에는 강력한 보장을 제공하기가 비교적 수월하다.
    - 비지역 데이터에 대해 부수효과를 주는 함수는 이렇게 하기가 무척 까다롭다.