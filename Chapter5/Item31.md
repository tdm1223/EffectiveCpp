# 항목 31. 파일 사이의 컴파일 의존성을 최대로 줄이자
- C++는 인터페이스와 구현을 깔끔하게 분리하는 일에 별로 일가견이 없다.
```cpp
#include "date.h"
#include "address.h"

class Person{
public:
    std::string address() const;
    std::string birthDate() const;
private:
    Date theBirthDate;  // 구현 세부사항
    Address theAddress; // 구현 세부사항
}
```
- `#include`문은 `Person`을 정의한 파일과 헤더 파일들 사이에 컴파일 의존성을 엮어버린다.
- 헤더 파일 중 하나라도 바뀌거나 이들과 엮여 있는 헤더파일이 바뀌기만 해도 `Person` 클래스를 정의한 파일은 다시 컴파일 된다.
- 컴파일러는 정의문을 만나면 객체를 담을 공간을 할당한다.
```cpp
int x;
Person p{params}; // 1
Person *p; // 2
```
1. Person 객체 하나의 크기를 알려면 **정의부**를 봐야 한다.
2. Person 객체의 **포인터를 담을 공간**만 할당하면 된다.
    - Java의 경우 해당 방식으로 이루어져 있다.
    

### 정의부에 대한 의존성을 선언부에 대한 의존성으로 바꾸자
- **객체 참조자** 및 **포인터**로 충분한 경우에는 객체를 직접 쓰지 않는다.
- **클래스 정의** 대신 **클래스 선언**에 최대한 의존하도록 만든다.
```cpp
class Date; // 클래스 선언

Date today();
void clearAppointments(Date d); // Date 클래스의 정의를 가져오지 않아도 된다.
```
- **선언부**와 **정의부**에 대해 별도의 헤더 파일을 제공한다.
```cpp
#include "datefwd.h" // Date 클래스를 선언하고 있는(정의하진 않는) 헤더 파일

Date today();
void clearAppointments(Date d);
```
- **핸들 클래스**와 **인터페이스 클래스**를 통해 구현부로부터 인터페이스를 떼어 놓아 파일들 사이의 컴파일 의존성을 완화시킬 수 있다.

### 핸들 클래스
- `pimpl` 관용구를 사용하는 클래스를 핸들 클래스라고 한다.
- 핸들 클래스의 멤버 함수를 호출하면 구현부 객체의 데이터까지 가기 위해 포인터를 타야 한다.
    - 한번 접근할 떄마다 요구되는 간접화 연산이 한 단계 더 증가한다.
- 객체 하나씩을 저장하는데 필요한 메모리 크기에 구현부 포인터의 크기가 더해지는것도 필수이다.
- 구현부 포인터가 동적 할당된 구현부 객체를 가리키도록 구현부 포인터의 초기화가 일어나야 한다.
- 인라인 함수의 도움을 제대로 끌어내기 힘들다.

### 인터페이스 클래스
- 핸들 클래스 대신 사용할 수 있는 방법이다.
- [기능을 나타내는 인터페이스를 추상 기본 클래스를 통해 마련해 놓고, 이 클래스로부터 파생 클래스를 만들 수 있게 하는것이다.](/Chapter6/Item34.md)
- 파생이 목적이기 때문에 데이터 멤버, 생성자가 없고 하나의 [가상 소멸자](/Chapter2/Item7.md)와 인터페이스를 구성하는 순수 가상 함수만 들어있다.
- 호출되는 함수가 전부 **가상함수**이다.
    - 함수 호출이 일어날 때마다 [가상 테이블 점프 비용](/Chapter2/Item7.md)이 소모된다.
- 인터페이스 클래스에서 파생된 객체는 **가상 테이블 포인터**를 지니고 있어야 한다.
- 인라인 함수의 도움을 끌어내기 힘들다.