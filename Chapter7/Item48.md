# 항목 48. 템플릿 메타프로그래밍, 하지 않겠는가?
## 템플릿의 장점
- 템플릿을 사용하면 객체를 생성하지 않더라도 타입에 값 을 부여할 수 있다.
- 타입들을 가지고 연산을 할 수 있다.
- 타입은 컴파일 타임에 확정되어야 하므로, 컴파일 타임에 모든 연산이 끝난다.

## 템플릿 메타 프로그래밍 (TMP : Template Meta Programming)
- **컴파일 도중**에 실행되는 **템플릿 기반**의 프로그램을 작성하는 일
- 템플릿 메타 프로그램은 `C++` 컴파일러가 실행시키는 `C++`로 만들어진 프로그램이다.
  - `TMP` 프로그램이 실행을 마친 후엔 **결과로 나온 출력물**이 다시 보통의 **컴파일 과정**을 거친다.
- 반복 의미의 루프는 없다.
  - **재귀**를 사용해서 루프의 효과를 낸다.
  - `TMP`의 루프는 재귀 함수 호출을 만들지 않고 **재귀식 템플릿 인스턴스화**를 한다.
- 튜링 안정성을 가지고 있다.
  - 범용 프로그래밍 언어처럼 어떤 것이든 계산할 수 있는 능력을 갖고 있다.

## 템플릿 메타 프로그래밍의 강점
### 다른 방법으로는 까다롭거나 불가능한 일을 쉽게 할 수 있다.
### 컴파일이 진행되는 동안에 실행되기 때문에, 기존 작업을 런타임 영역에서 컴파일 타임 영역으로 전환할 수 있다.
- 일반적으로 프로그램 실행 도중에 잡혀 왔던 몇몇 에러들을 **컴파일** 도중에 찾을 수 있다.
- `TMP`를 써서 만든 `C++` 프로그램이 확실히 모든 면에서 **효율적**일 여지가 많다.

## TMP 예제
- `Factorial` 예제
```cpp
// 일반적인 경우
template<unsigned n>
struct Factorial {
    enum { value = n * Factorial<n - 1>::value };
};

// 특수한 경우: Factorial<0>의 값은 1
template<>
struct Factorial<0> {
    enum { value = 1 };
};

std::cout << Factorial<5>::value << endl; // 120을 런타임 계산 없이 출력
std::cout << Factorial<10>::value << endl; // 3628800을 런타임 계산 없이 출력
```

## C++ 프로그래밍에서 TMP를 제대로 활용할 수 있는 예
### 치수 단위의 정확성 확인
- 과학 기술 분야의 응용프로그램을 만들 때는 치수 단위가 똑바로 조합되어야 하는것이 최우선이다.
- TMP를 사용하면 프로그램 안에서 쓰이는 모든 치수 단위의 조합이 제대로 됐는지를 계산 시간에 상관없이 맞춰(컴파일 동안에) 볼 수 있다.
- 분수식 지수 표현이 지원된다.
  - 컴파일 도중에 분수의 약분이 가능하기 때문이다.

### 행렬 연산의 최적화
- TMP를 응용한 고급 프로그래밍 기술인 표현식 템플릿을 사용하면 덩치 큰 임시 객체를 없애고 루프까지 합칠 수 있다.

### 맞춤식 디자인 패턴 구현의 생성
- 정책 기반 설계를 사용하면 따로따로 마련된 설계상의 선택(정책)을 나타내는 템플릿을 만들어 낼 수 있다.
- 생성식 프로그래밍의 기초
