# 구현

## 변수 정의는 늦출 수 있는 데까지 늦추기
- 생성자나 소멸자를 끌고 다니는 타입으로 변수를 정의하면 문게 되는 비용이 두개가 된다.
- 변수가 정의됐으나 사용되지 않은 경우에도 비용이 부과된다.
```cpp
std::string encryptPassword(const std::string& password)
{
    using namespace std;

    string encrypted; // string 변수 선언

    if (password.length() < MinimumPasswordLength)
    {
        throw logic_errod("Password is too short");
    }

    // 비밀번호 암호화 하는 로직

    return encrypted;
}
```
- 위 코드에서 `encrypted` 객체는 예외가 발생하면 사용되지 않는 객체이다.
- 따라서 해당 변수를 정의하는 일은 예외처리 아래까지 미루는 편이 낫다.

### 조금더 미루어보자
```cpp
std::string encryptPassword(const std::string& password)
{
    // 같은 로직

    string encrypted; // 기본 생성자에 의해 만들어지는 encrypted
    encrypted = password; // encrypted에 password를 대입

    encrypt(encrypted);
    return encrypted;
}
```
- 위 코드에서 바람직한 방법은 `encrypted`를 `password`로 초기화해 버리는 방법이다.
- 의미도 없고 비용도 만만치 않을 듯한 **기본 생성자** 호출을 건너뛸수 있게 된다.

### 조금더 미루어보자2
```cpp
std::string encryptPassword(const std::string& password)
{
    // 같은 로직

    string encrypted(password); // 정의와 동시에 초기화

    encrypt(encrypted);
    return encrypted;
}
```
- 위처럼정의와 동시에 초기화 함으로써 성능을 높일 수 있고 프로그램도 깔끔해 진다.

## 캐스팅은 절약, 또 절약
- 정말 잘 작성된 C++ 코드는 캐스팅을 거의 쓰지 않는다.

### 네 가지 캐스트 연산자
1. `const_cast`
    - 상수성을 없애는 용도
2. `dynamic_cast`
    - 안전한 다운 캐스팅
3. `reinterpret_cast`
    - 하부 수준 캐스팅
4. `static_cast`
    - 암시적 변환

### 캐스팅을 써야할 경우
- 객체를 인자로 받는 함수에 객체를 넘기기 위해 **명시 호출 생성자**를 호출하고 싶을 경우
- 캐스팅이 어쩔 수 없이 필요하다면, 함수 안에 숨길수 있도록 하는것이 좋다.
- 캐스트 연산자가 입맛 당기는 상황이라면 뭔가 꼬여가는 징조다.

### 캐스팅은 다른 타입으로 처리하라고 컴파일러에게 알려주는것이 아니다.
```cpp
class Base{};
class Derived:public Base{};
Derived d;
Base* pb = &d;
```
- 포인터의 `offset`을 `Derived*` 포인터에 적용하여 실제의 `Base*` 포인터 값을 구하는 동작이 런타임에 이루어진다.
- 객체 하나가 가질 수 있는 주소가 한개가 아니라 그 이상이 될 수 있음을 보여주는 사례가 된다.

### dynamic_cast
- 상당수의 구현환경에서 이 연산자가 정말 느리게 구현되어 있다.
- **파생 클래스** 객체임이 분명해 **파생 클래스**의 함수를 호출하고 싶은데, 그 객체를 조작할 수 있는 수단으로 **기본 클래스**의 포인터밖에 없을 경우 사용하게 된다.
- 해결 방법
    1. 파생 클래스 객체에 대한 포인터를 컨테이너에 담아줌으로써 각 객체를 기본 클래스 인터페이스를 통해 조작할 필요를 제거한다.
    2. 원하는 조작을 가상 함수 집합으로 정리해서 기본 클래스에 넣어둔다.

## 내부에서 사용하는 객체에 대한 '핸들'을 반환하는 코드는 피하기
```cpp
// 점을 나타내는 클래스
class Point{
public:
    Point(int x, int y);
    void SetX(int newVal);
    void SetY(int newVal);
};

struct RectData{
    Point ulhc;
    Point lrhc;
};

class Rectangle{
public:
    Point& upperLeft() const {return pData->ulhc;}
    Point& lowerRight() const {return pData->lrhc;}
private:
    std::shared_ptr<RectData> pData;
};

const Rectangle rec(coord1, coord2);
rec.upperLeft().setX(50);
```
- upperLeft를 호출한 쪽은 rec의 숨겨진 Point 데이터 멤버를 참조자로 끌어와 바꿀수 있는 문제가 발생한다.
    - rec은 상수 객체로 선언되어있다.

### 위 예제로 알 수 있는 점
1. 클래스 데이터 멤버는 그 멤버의 참조자를 반환하는 함수들의 최대 접근도에 따라 캡슐화 정도가 정해진다.
2. 어떤 객체에서 호출한 상수 멤버 함수의 참조자 반환 값의 실제 데이터가 그 객체의 바깥에 저장되어 있다면, 이 함수의 호출부에서 그 데이터의 수정이 가능하다.


- 참조자, 포인터 및 반복자는 모두 핸들이다.
    - 어떤 객체의 내부요소에 대한 핸들을 반환하게 만들면 언제든지 그 객체의 캡슐화를 무너뜨리는 위험이 존재한다.
- 어떤 객체의 내부요소에는 데이터 멤버 뿐만 아니라 일반적인 수단으로 접근이 불가능한 멤버 함수도 내부요소에 포함된다.

### 해결책
```cpp
const Point& upperLeft() const {return pData->ulhc;}
const Point& lowerRight() const {return pData->lrhc;}
```
- upperLeft(), lowerRight() 반환 타입에 const 키워드를 붙여준다.
    - 사용자는 사각형을 정의하는 꼭짓점 쌍을 읽을 수는 있지만 쓸 수는 없게 된다.

### upperLeft 함수와 lowerRight 함수에서 내부 데이터에 대한 핸들을 반환하고 있는 부분이 남아있다.
```cpp
class GUIObject{};
const Rectanble boundingBox(const GUIObject& obj);

GUIObject * pgo;
const Point *pUpperLeft = &(boundingBox(*pgo).upperLeft());
```
- 마지막 문장의 흐름
    1. `boundingBox`함수 호출시 `Rectangle` 임시 객체 생성
    2. 생성된 임시 객체에 대해 `upperLeft` 호출 (`Point` 객체중 하나에 대한 참조자가 나옴)
    3. 위에서 나온 참조자에 & 연산자를 건 결과 값(주소)이 `pUpperLeft` 포인터에 대입
    4. 문장이 끝날 무렵, `boundingBox`함수의 반환 값(임시 객체)이 소멸
    5. 임시 객체가 소멸되니 그 안에 들어 있는 Point 객체들도 덩달아 소멸
    6. `pUpperLeft` 포인터가 가리키는 객체는 없어진다.
- `pUpperLeft`에게 객체를 달아 줬다가(생성된 임시 객체) **주소 값**만 남기고 모두 빼앗아 간 꼴이 된다.
- 위의 코드처럼 객체의 내부에 대한 핸들을 반환하는 함수는 위험하다.

## 예외 안정성이 확보되는 그낭 위해 싸우고 또 싸우기
- 소프트웨어 시스템은 예외에 **안전**하거나, 예외에 **뚫려** 있거나 둘중 하나이다.
- 예외 안전성이 없는 함수가 한 개라도 쓰고 있으면, 그 시스템은 전부가 예외에 안전하지 않은 시스템이다.

### 예외 안전성을 가진 함수
1. **자원**이 새도록 만들지 않는다.
2. **자료구조**가 더럽혀지는 것을 허용하지 않는다.

#### 예외 안전성을 갖춘 함수는 아래 보장중 하나를 제공한다.
1. 기본적인 보장(basic guarantee)
    - 함수 동작 중에 예외가 발생하면, 실행 중인 프로그램에 관련된 모든 것들을 **유효한 상태로 유지**하겠다는 보장
    - 어떤 객체나 자료구조도 더럽혀지지 않으며, 모든 객체의 상태는 내부적으로 일관성을 유지하고 있다.
    - 프로그램 상태가 정확히 어떠한지 예측이 안 될 수도 있다.
2. 강력한 보장(basic guarantee)
    - 함수 동작 중에 예외가 발생하면, 프로그램의 상태를 **절대로 변경하지 않겠다**는 보장
    - 호출이 성공하면 마무리까지 완벽하게 성공하고, 호출이 실패하면 함수 호출이 없었던 것처럼 프로그램의 상태가 되돌아 간다.
3. 예외불가 보장(basic guarantee)
    - 예외를 **절대로 던지지 않겠다**는 보장
    - 약속한 동작은 언제나 끝까지 완수하는 함수
    - 기본 제공 타입(int, 포인터 등)에 대한 모든 연산은 예외를 던지지 않게 되어있다.

- 현실적으로 대부분의 함수에 있어서 **기본적인 보장**과 **강력한 보장** 중 하나를 고르게 된다.

### 복사 후 맞바꾸기 전략
- **강력한 예외 안전성 보장**을 제공하기 위한 설계 전략
    - 어떤 객체를 수정하고 싶으면 그 객체의 **사본**을 하나 만들어 놓고 그 **사본을 수정**하는 것
    - 수정 동작 중에 실행되는 연산에서 예외가 전져지더라도 원본 객체는 바뀌지 않는다.
    - 필요한 동작이 전부 성공적으로 완료되고 나면 수정된 객체를 원본 객체와 맞바꾼다.(예외를 전지지 않는 연산 내부에서 수행)
- 진짜 객체의 모든 데이터를 별도의 구현 객체에 넣어두고 구현 객체를 가리키는 포인터를 진짜 객체가 물고 있게 하는 식으로 구현한다.
    - pimpl 관용구라고도 한다.
- 수정하고 싶은 객체를 복사해 둘 공간과 복사에 걸리는 시간을 감수해야 한다.

### 함수의 부수효과(side effect)
- 자기 자신에만 국한된 것들의 상태를 바꾸며 동작하는 함수의 경우에는 강력한 보장을 제공하기가 비교적 수월하다.
    - 비지역 데이터에 대해 부수효과를 주는 함수는 이렇게 하기가 무척 까다롭다.

## 인라인 함수는 미주알고주알 따져서 이해해 두기
- 인라인 함수를 사용하면 컴파일러가 함수 본문에 문맥별 최적화를 걸기가 용이하다.
- 본문 길이가 짧은 인라인 함수를 사용하면, 함수 본문에 대해 만들어지는 코드의 크기가 함수 호출문에 대해 만들어지는 코드보다 작아질 수 있다.
- 인라인을 남발하면 프로그램 커기가 커질 수 있다.
    - 기계에서 쓸 수 있는 공간을 넘을 수 있다.
    - 가상 메모리를 쓰더라도 성능의 걸림돌이 될 수 있다.
        - 페이징 횟수가 늘어난다.
        - 명령어 캐시 적중률이 떨어진다.
- 인라인 함수는 헤더 파일에 들어 있어야 한다.
    - 대부분의 빌드 환경에서 인라인을 컴파일 도중에 수행하기 때문이다.
- 인라인 함수는 대부분의 디버거가 곤란해 하는 비호감 대상이다.

### 컴파일러가 인라인 함수의 후보를 결정하는것
- `inline`은 컴파일러 선에서 무시할 수 있는 요청이고 컴파일러가 판단하여 `inline` 함수로 바꾼다.
- 아무리 인라인 함수로 선언되어 있어도 컴파일러가 보기에 복잡한 함수는 절대로 인라인 확장의 대상에 넣지 않는다.
- 간단한 함수더라도 가상 함수 호출 같은것은 절대로 인라인해 주지 않는다.
1. 클래스 정의 안에 함수를 바로 정의해 넣으면 컴파일러는 함수를 인라인 후보로 찍는다.
2. 함수 정의 앞에 inline 키워드를 붙인다.
    - 예로 표준 라이브러리의 max 템플릿이 있다.

### inline 사용 기본 전략
- 우선은 아무것도 인라인하지 않는다.
- 꼭 인라인 해야 하는 단순한 함수에 한해서만 인라인 함수로 선언한다.
- 디버깅하고 싶은 부분에서 디버거를 제대로 쓸 수 있도록 만들어야 한다.
- 필요한 위치에 인라인 함수를 놓는다(수동 최적화)
